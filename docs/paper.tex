\documentclass[conference]{IEEEtran}

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xurl}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{microtype}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Implementing XBF: An Efficient Self-Describing Binary Format}

\author{
	\IEEEauthorblockN{David Krauthamer}
	\IEEEauthorblockA{\textit{Electrical and Computer Engineering Department} \\
		\textit{Stevens Institute of Technology}\\
		Hoboken, USA \\
		dkrautha@pm.me}
	\and
	\IEEEauthorblockN{Dov Kruger}
	\IEEEauthorblockA{\textit{Electrical and Computer Engineering Department} \\
		\textit{Stevens Institute of Technology}\\
		Hoboken, USA \\
		dkruger@stevens.edu}
}

\maketitle

\begin{abstract}
	Do later
\end{abstract}

\begin{IEEEkeywords}
	Data format, XML, JSON, Binary data
\end{IEEEkeywords}

\section{Introduction}

On the web, data is largely interchanged in one of two formats, XML (Extensible Markup Language)\cite{xml_spec} or JSON (JavaScript Object Notation)\cite{json_spec}. These formats have two key features that have led to their popularity, human-readability and being self-describing. These features have inherent inefficiencies, which XBF (Xtensible Binary Format)\cite{xbf_spec} intends to solve through carefully chosen compromises.

\subsection{Self-Description}

A self-describing format is a format in which a recipient is not required to have a schema for the incoming data, and the names and types of the data being sent can be determined from the data itself. The following is an example of XML:

\begin{lstlisting}[language=XML]
<person>
	<name>John Jackson</name>
	<age>25</age>
</person>
\end{lstlisting}

This example represents a person object with two fields, a string name and integer age. The downside to being self-describing is wasted characters on the metadata describing the object. In this particular example, 14 characters of the 59 total characters actually contain the desired data, the rest are just describing the metadata. The best thing a format can do is minimize this overhead as much as possible, it cannot be eliminated while still being self-describing.

An additional optimization that could be made (but isn't with either of these formats) is deduplication of the metadata. Both JSON and XML include the metadata for every element sent, even if what is being sent is a homogenous list of elements that all share the same structure.

\subsection{Human Readability}

A human-readable format is one where data is encoded entirely as ASCII or UTF-8 characters, and formatted in such a way that a person could easily read or write it without the need of a machine. Human-readability brings with it two inefficiencies, the need to parse text data into a binary format that a computer understands, and additional overhead from whitespace characters.

\subsection{Enhancements Made}

With the inefficiencies of these two formats in mind, XBF seeks to improve on them through a few core design decisions:

\begin{IEEEitemize}
	\item Send data and metadata in a binary format (no longer human-readable).
	\item Remain self-describing, but have the option to not include metadata if it's already known, and deduplicate metadata whenever possible.
	\item Prioritize simplicity in the type system.
\end{IEEEitemize}

\section{Format Design}

Similar to CSV (cite here?), we send a single header up front, followed by all the data. For a primitive type there isn't a large savings here, but there are massive savings with vectors and structs. With a vector the metadata is a discriminant indicating a vector is being sent, which is then followed by the metadata for its internal type. This process continues recursively if the inner type (or any of its inner types) contains a vector or struct, ensuring that all metadata necessary to represent the data coming afterward is received up front. The data is then sent in a single continuous block, something after this...

\section{Implementation}

The reference implementation for XBF\cite{xbf_impl} is written in Rust\cite{rust}. Rust was chosen for the following reasons:
\begin{IEEEitemize}
	\item Rust is statically typed and compiled, and allows for similarly efficient code generation to C/C++.
	\item A powerful type system with tagged unions built-in\cite{enums} such that dynamic dispatch and virtual method tables weren't required, and structural pattern matching was used instead.
	\item Rust provides statically checked memory safety through the concept of ownership\cite{ownership}.
	\item A built-in testing system in the standard library\cite{testing}.
	\item Errors are represented as values rather than throwing exceptions\cite{results}.
\end{IEEEitemize}

\subsection{Values}

At the top of the hierarchy of types is a generic value, named the XbfType. This is a tagged union of all possible types, consisting of Primitives (XbfPrimitive) \ref{primitives}, Vectors (XbfVec)
\ref{vec}, and Structs (XbfStruct) \ref{struct}. The corresponding metadata is the XbfMetadata, a tagged union of metadata types of each of the aforementioned subtypes. In order to perform a downcast on either of these top level types, Rust's structural pattern matching must be used.

\subsection{XbfPrimitive}\label{primitives}

The implementation of primitives is a tagged union of all possible primitive types, mapping the XBF type to the Rust native equivalent as shown in Table \ref{type_map}. The exceptions are the 256-bit integer types, which do not have an analog, and are instead represented by an array of four unsigned 64-bit integers.

\begin{table}[htbp]
	\caption{XBF Type Map}\label{type_map}
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			\textbf{XBF Type} & \textbf{Rust Type}          & \textbf{C++ Type}                         \\
			\hline
			Boolean           & bool                        & bool                                      \\
			U8                & u8                          & uint8\_t                                  \\
			U16               & u16                         & uint16\_t                                 \\
			U32               & u32                         & uint32\_t                                 \\
			U64               & u64                         & uint64\_t                                 \\
			U128              & u128                        & uint64\_t[2]                              \\
			U256              & [u64; 4]                    & uint64\_t[4]                              \\
			I8                & i8                          & int8\_t                                   \\
			I16               & i16                         & int16\_t                                  \\
			I32               & i32                         & int32\_t                                  \\
			I64               & i64                         & int64\_t                                  \\
			I128              & i128                        & uint64\_t[2]                              \\
			I256              & [u64; 4]                    & uint64\_t[4]                              \\
			F32               & f32                         & float                                     \\
			F64               & f64                         & double                                    \\
			Bytes             & Vec\textless u8\textgreater & std::vector\textless uint8\_t\textgreater \\
			String            & String                      & std::string                               \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Metadata for integers is an enumeration of the possible primitive metadata discriminant values, ranging from 0 to 16, represented as unsigned 8-bit integers.

\subsection{XbfVec}\label{vec}

XbfVec is implemented as a native dynamic array of XbfType values, and a Rc (reference counted, shared pointer) to the metadata of its inner type, represented as the base XbfMetadata. In order to ensure XbfVec remains homogenous, it requires the metadata to be passed in at construction time. If all the values given to the constructor do not have the same metadata as the metadata passed in, the constructor returns an error type.

The metadata is implemented with a Rc because Rust's tagged unions are not allowed to be recursive, as then they could be infinitely sized on the stack. A pointer type has a known sized value, and as such the tagged union can then be created on the stack by the compiler. The recursion comes from the base XbfMetadata type, which can contain XbfVecMetadata, which contains an XbfMetadata, and the recursion can continue.

XbfVecMetadata could have been implemented with an owning pointer (known as a Box\textless T\textgreater), however that would mean that the metadata couldn't be shared among many instances of an object. When XbfVec is deserialized, it passes the internal metadata to each of the inner values it deserializes and constructs, which causes the reference count to increase and all the inner values to share the same heap allocated metadata. While this does not affect the on the wire performance, this does reduce memory usage for a user of the library.

\subsection{XbfStruct}\label{struct}

XbfStruct is implemented in a very similar manner to XbfVec, consisting of a Rc to the metadata of the struct, and a Box\textless [XbfType]\textgreater\space containing the fields. This type is known as a boxed slice. In Rust, a slice is a pair of a pointer to contiguous memory and a length. When a slice is boxed, it is allocated on the heap, and the box object is the sole owner of that heap allocation, and will de-allocate it when the box goes out of scope. The reason a boxed slice was chosen instead of a dynamic array was to save on memory usage.

A Vec\textless T\textgreater (dynamic array) in Rust consists of a pointer to memory, a capacity of how much memory is available at that address, and a length of how many elements have been properly initialized. The amount of fields of a struct are not allowed to change, so a boxed slice can be used instead of a dynamic array, thereby saving the size of a pointer of memory for every XbfStruct created.

The metadata of structs (XbfStructMetadata) is the most complex of the three metadata types. It consists of boxed string slice and an IndexMap\cite{indexmap} mapping string slices to XbfMetadata types.

In Rust there is an important distinction between an owned String, and a string slice\cite{strings}. A string slice is similar to the previously mentioned slices, except it consists of valid UTF-8 code points. It is a view into a block of memory, and its size cannot be modified. If growable string is required, that's where the String type is used. It makes the same UTF-8 guarantee as a string slice, but has the same properties as a Vec where it keeps track of its capacity, will reallocate if its capacity is exceeded, similar to a dynamic array. As with the decision to use a slice in XbfStruct, a string slice is utilized to save on memory usage, as the metadata for a struct shouldn't need to change, thereby making a capacity field irrelevant.

An IndexMap is a hash table with consistent order and fast iteration. Ordinarily a hash table does not keep track of the order it's fields are inserted, which is a problem when serializing the metadata, as the fields could be sent in any order. A dynamic array of objects consisting of the field name and type could be used, however this leads to $O(n)$ searches for a given field. In order to retain $O(1)$ searches, an IndexMap was used. It requires extra memory overhead to keep track of the insertion order of keys and values, but ensures that iteration is fast and in a consistent order.

\subsection{Testing}\label{testing}

\section{Evaluation}

XBF was evaluated against a number of other self-describing data interchange formats.

\begin{IEEEitemize}
	\item CSV (Comma Separated Values)\cite{csv_spec}\cite{csv_parser}
	\item MessagePack\cite{msgpack_spec}\cite{msgpack_parser}
	\item CBOR (Concise Binary Object Representation)\cite{cbor_spec}\cite{cbor_parser}
	\item JSON\cite{json_parser}
	\item XML\cite{xml_parser}
\end{IEEEitemize}

The test consisted of two components, a client and a server, both written in Rust. The server downloaded a year of Sony stock data from Yahoo Finance\cite{sony_stock_data} in CSV format, and parsed it into a list of objects. Next, the original size of the CSV and a calculated value for how much memory is taken up by the parsed list was logged. Finally, the server waited for connections, and depending on the request received, serialized the list of objects into the requested format and sent it to the client. The serialized data was not cached, and the serialization was performed for each request.

The client performed the time measurement, as well as initiated connections to the server. For each data format, the client sent 100 requests to the server, and recorded the time it took from initiating the connection to receiving all the data. The average of the time for these 100 requests was then recorded, along with how large each response received was in bytes.

The server was a DigitalOcean Droplet\cite{digital_ocean} running Ubuntu 20.04.5 located in New York City. The client was a laptop running openSUSE Tumbleweed located in Hoboken, NJ.

\section{Results}

\begin{table}[htbp]
	\caption{Average Time and Bytes Read}
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			\textbf{Format} & \textbf{Avg Time (ms)} & \textbf{Bytes Read} \\
			\hline
			CSV             & 18.93                  & 16,411              \\
			MessagePack     & 11.22                  & 15,565              \\
			CBOR            & 16.95                  & 25,507              \\
			JSON            & 21.91                  & 31,180              \\
			XML             & 21.87                  & 43,699              \\
			XBF             & 11.32                  & 14,686              \\
			\hline
		\end{tabular}
	\end{center}\label{time_and_bytes}
\end{table}

\begin{table}[htbp]
	\caption{Format Overheads}
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			\textbf{Format} & \textbf{Overhead (bytes)} & \textbf{Percent Overhead} \\
			\hline
			CSV             & 1,823                     & 11.1                      \\
			MessagePack     & 977                       & 6.22                      \\
			CBOR            & 10,919                    & 42.8                      \\
			JSON            & 16,592                    & 53.2                      \\
			XML             & 29,111                    & 66.6                      \\
			XBF             & 98                        & 0.67                      \\
			\hline
		\end{tabular}
	\end{center}\label{overhead}
\end{table}

Original CSV data size recorded by the server: 17,160 bytes.

Native data size recorded by the server: 14,558 bytes.

\section{Discussion}

XBF performed significantly faster than all except one of the other formats tested, despite minimal effort spent optimizing the reference implementation's runtime performance. Additionally, XBF has the smallest overhead of the formats tested, indicating that it would make a good choice for IOT (internet of things) systems which need to transfer data in a low bandwidth scenario. Based on the overall

\section{Conclusion}

The results obtained indicate that there is still significant room for improvement in the formats used for data interchange. The primary technique of metadata deduplication shows the overhead of sending self-describing data can be reduced greatly. This technique could also be applied to a human-readable format such as JSON or XML, and would provide similar benefits even if the data is transferred as text instead of binary.

In the self-describing binary format space, there are still many improvements that could be made in the future to XBF. Sizes for variable length

\bibliographystyle{IEEEtran}
\bibliography{refs}
\end{document}
