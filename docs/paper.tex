\documentclass[conference]{IEEEtran}

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xurl}
\usepackage{xcolor}
\usepackage{listings}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Implementing XBF: An Efficient Self-Describing Binary Format}

\author{
	\IEEEauthorblockN{David Krauthamer}
	\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
		\textit{name of organization (of Aff.)}\\
		City, Country \\
		dkrautha@pm.me}
	\and
	\IEEEauthorblockN{Dov Kruger}
	\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
		\textit{name of organization (of Aff.)}\\
		City, Country \\
		email address or ORCID}
	% \and
	% \IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
	% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
	% 	\textit{name of organization (of Aff.)}\\
	% 	City, Country \\
	% 	email address or ORCID}
}

\maketitle

\begin{abstract}
	Do later
\end{abstract}

\begin{IEEEkeywords}
	Data format, XML, JSON, Binary data
\end{IEEEkeywords}

\section{Introduction}

On the web, data is largely interchanged in one of two formats, XML (Extensible Markup Language)\cite{xml_spec} or JSON (JavaScript Object Notation)\cite{json_spec}. These formats have two key features that have led to their popularity, human-readability and being self-describing. These features have inherent inefficiencies, which XBF (Xtensible Binary Format)\cite{xbf_spec} intends to solve through carefully chosen compromises.

\subsection{Self-Description}

A self-describing format is a format in which a recipient is not required to have a schema for the incoming data, and the names and types of the data being sent can be determined from the data itself. The following is an example of XML:

\begin{lstlisting}[language=XML]
<person>
	<name>John Jackson</name>
	<age>25</age>
</person>
\end{lstlisting}

This example represents a person object with two fields, a string name and integer age. The downside to being self-describing is wasted characters on the metadata describing the object. In this particular example, 14 characters of the 59 total characters actually contain the desired data, the rest are just describing the metadata. The best thing a format can do is minimize this overhead as much as possible, it cannot be eliminated while still being self-describing.

An additional optimization that could be made (but isn't with either of these formats) is deduplication of the metadata. Both JSON and XML include the metadata for every element sent, even if what is being sent is a homogenous list of elements that all share the same structure.

\subsection{Human Readability}

A human-readable format is one where data is encoded entirely as ASCII or UTF-8 characters, and formatted in such a way that a person could easily read or write it without the need of a machine. Human-readability brings with it two inefficiencies, the need to parse text data into a binary format that a computer understands, and additional overhead from whitespace characters.

\subsection{Enhancements Made}

With the inefficiencies of these two formats in mind, XBF seeks to improve on them through a few core design decisions:

\begin{IEEEitemize}
	\item Send data and metadata in a binary format (no longer human-readable).
	\item Remain self-describing, but have the option to not include metadata if it's already known, and deduplicate metadata whenever possible.
	\item Prioritize simplicity in the type system.
\end{IEEEitemize}

\section{Format Design}

\section{Implementation}

\section{Evaluation}

XBF was evaluated against a number of other self-describing data interchange formats.

\begin{IEEEitemize}
	\item CSV (Comma Separated Values)\cite{csv_spec}\cite{csv_parser}
	\item MessagePack\cite{msgpack_spec}\cite{msgpack_parser}
	\item CBOR (Concise Binary Object Representation)\cite{cbor_spec}\cite{cbor_parser}
	\item JSON\cite{json_parser}
	\item XML\cite{xml_parser}
\end{IEEEitemize}

The test consisted of two components, a client and a server, both written in Rust. The server downloads a year of Sony stock data from Yahoo Finance\cite{sony_stock_data} in CSV format, and parses it into a list of objects. The original size of the CSV and a calculated value for how much memory is taken up by the parsed list is logged. It then waits for connections, and depending on the request received, serializes the list of objects into the requested format and sends it to the client. The serialized data is not cached, and the serialization is performed for each request.

The client performs the time measurement, as well as initiates connections to the server. For each data format, the client sends 100 requests to the server, recording the time it takes from initiating the connection to receiving all the data. The average of the time for these 100 requests is then recorded, along with how large each response received was in bytes.

\section{Results}

\begin{table}[htbp]
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			\textbf{Format} & \textbf{Avg Time (ms)} & \textbf{Bytes Read} \\
			\hline
			CSV             & 18.931802              & 16411               \\
			MessagePack     & 11.220957              & 15565               \\
			CBOR            & 16.957873              & 25507               \\
			JSON            & 21.912745              & 31180               \\
			XML             & 21.873043              & 43699               \\
			XBF             & 11.322245              & 14686               \\
			\hline
		\end{tabular}
		\label{results}
	\end{center}
\end{table}

See the \ref{results}

\section{Discussion}

\section{Conclusion}

\bibliographystyle{IEEEtran}
\bibliography{refs}
\end{document}
