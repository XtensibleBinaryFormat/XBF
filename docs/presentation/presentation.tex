\documentclass{beamer}
\usepackage{amsfonts,amsmath,oldgerm}
\usepackage{bytefield}
\usetheme{sintef}
\usefonttheme[onlymath]{serif}
\titlebackground*{assets/background}

\newcommand{\rot}[1]{\rotatebox{90}{#1}}

\title{Implementing XBF: An Efficient Self-Describing Binary Format}
% \subtitle{Using \LaTeX\ to prepare slides}
% \course{Master's Degree in Computer Science}
\author{\href{mailto:dkrautha@pm.me}{David Krauthamer}}
% \IDnumber{1234567}

\setbeameroption{show notes}

\begin{document}
\maketitle

% \begin{frame}
%
% 	This template is based on \hrefcol{https://www.overleaf.com/latex/templates/sapienza-presentation/yyksmrskffhk}{Sapienza Presentation} from \hrefcol{mailto:andrea@gasparini.cloud}{Andrea Gasparini}
%
% 	\vspace{\baselineskip}
%
% 	The above template is a based on \hrefcol{https://www.overleaf.com/latex/templates/sintef-presentation/jhbhdffczpnx}{SINTEF Presentation} from \hrefcol{mailto:federico.zenith@sintef.no}{Federico Zenith} and its derivation \hrefcol{https://github.com/TOB-KNPOB/Beamer-LaTeX-Themes}{Beamer-LaTeX-Themes} from Liu Qilong
%
% 	\vspace{\baselineskip}
%
% 	In the following you find a brief introduction on how to use \LaTeX\ and the beamer package to prepare slides, based on the one written by \hrefcol{mailto:federico.zenith@sintef.no}{Federico Zenith} for \hrefcol{https://www.overleaf.com/latex/templates/sintef-presentation/jhbhdffczpnx}{SINTEF Presentation}
%
% 	% This template is released under \hrefcol{https://creativecommons.org/licenses/by-nc/4.0/legalcode}{Creative Commons CC BY 4.0} license
%
% \end{frame}

\section{Introduction}

\begin{frame}{Web Data Interchange Formats}
	\begin{itemize}
		\item Human-Readable and Self-Describing
		      \note[item]{Most formats on the web are human-readable and self-describing}
		      \note[item]{Self describing means they include metadata to describe themselves, and don't require an external schema}
		      \note[item]{Human readable means plain text, ASCII or utf-8}
		\item Most common: JSON and XML
		      \note[item]{The most common of these formats is JSON and XML}
		\item Alternatives: CSV, MessagePack, CBOR
		      \note[item]{There are other human-readable formats such as CSV}
		      \note[item]{And others, such as CBOR (concise binary object representation), and MessagePack that are still self-describing, but use a binary format instead}
	\end{itemize}
\end{frame}

\begin{frame}{Shortcomings of Current Formats}
	\begin{itemize}
		\item Repeated sending of metadata.
		\item Inefficiency of plain text.
		      \note[item]{Expensive conversion between plain text and binary}
		      \note[item]{Requires more bytes to store the same data}
		\item Use of big-endian.
		      \note[item]{Most modern processors (x86 and ARM) are little-endian}
	\end{itemize}
\end{frame}

\begin{frame}{Improvements}
	\begin{itemize}
		\item When possible, send metadata only a single time (mainly for homogenous lists).
		\item Allow sending metadata to be optional, such as if a client already has it.
		      \note[item]{Keep metadata and data separate, not coupled together}
		\item Utilize little-endian to reduce conversions.
		\item Prioritize a simple type system.
		      \note[item]{Hopefully makes the implementation simpler}
	\end{itemize}
\end{frame}

\section{Format Design}

\begin{frame}{Primitives}
	\begin{itemize}
		\item Boolean
		      \note[item]{True of False, one byte}
		      \note[item]{All integers are little-endian}
		      \note[item]{Integer types are equivalent to the types in stdint.h C header}
		\item U8, U16, U32, U64, U128, U256
		      \note[item]{Unsigned Integer Types}
		      \begin{itemize}
			      \item Equivalent to uint*\_t types in C
		      \end{itemize}
		\item I8, I16, I32, I64, I128, I256
		      \note[item]{Signed Integer Types}
		      \begin{itemize}
			      \item Equivalent to int*\_t types in C
		      \end{itemize}
		\item F32, F64
		      \note[item]{Floating Point Types}
		      \begin{itemize}
			      \item IEEE 754 floating point numbers
		      \end{itemize}
		\item Bytes  (Non-UTF-8 Bytes)
		      \note[item]{String but doesn't have to be UTF-8}
		\item String (UTF-8 Bytes)
		      \note[item]{Sends length as u64 followed by UTF-8 bytes}
	\end{itemize}
\end{frame}

\begin{frame}{Primitive Metadata}
	\center
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Type} & \textbf{Discriminant} \\
		\hline
		Boolean       & 0                     \\
		U8            & 1                     \\
		U16           & 2                     \\
		U32           & 3                     \\
		...           & ...                   \\
		I256          & 12                    \\
		F32           & 13                    \\
		F64           & 14                    \\
		Bytes         & 15                    \\
		String        & 16                    \\
		\hline
	\end{tabular}
	\note[item]{Metadata is sent as a single byte discriminant value}
	\note[item]{The discriminant begin at 0 with Boolean, and increase by 1 for each type}
	\note[item]{Progress in the same order as the previous slide, with String being the final value}
\end{frame}

\begin{frame}[fragile]{Primitive Example}
	\begin{itemize}
		\item 16-Bit Unsigned Integer: 1024 \\
		      \begin{bytefield}{24}
			      \bitbox{8}{Disc} & \bitbox{16}{1024} \\
			      \bitbox{8}{2} & \bitboxes{8}{04} \\
		      \end{bytefield}
		\item String: "hello" \\
		      \begin{bytefield}[bitheight=\widthof{"Disc"}]{28}
			      \bitbox{2}{\rot{Disc}} & \bitbox{16}{length} & \bitboxes{2}{hello} \\
			      \bitboxes{2}{{16} {2} {0} {0} {0} {0} {0} {0} {0} {\rot{104}} {\rot{101}} {\rot{108}} {\rot{108}} {\rot{111}}}
		      \end{bytefield}

	\end{itemize}
\end{frame}

\begin{frame}{Vectors (Homogenous Lists)}
	\begin{itemize}
		\item Homogenous list of values that has a known, variable length.
		\item Length is sent as a part of the type, not in metadata.
		      \note[item]{Length is an u64, the same as String and Bytes}
		\item Length is sent, followed by the elements.
		      \note[item]{No type info about elements, that's in metadata}
		\item Inner type Information is \emph{not} sent.
	\end{itemize}
\end{frame}

\begin{frame}{Vector Metadata}
	\begin{itemize}
		\item Single byte discriminant value is sent (String + 1).
		\item Followed by internal type metadata (can continue recursively).
		\item Length is \emph{not} sent.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Vector Example}
	\begin{center}
		\textbf{Vector of 16-Bit Unsigned Integers:} [42, 1024]

		DV = Discriminant of a Vector

		D16 = Discriminant of a 16-Bit Unsigned Integer

		\begin{bytefield}{26}
			\bitbox{2}{\rot{DV}} & \bitbox{2}{\rot{D16}} & \bitbox{16}{length} & \bitboxes{4}{{42} {1024}} \\
			\bitboxes{2}{{17} {2} {2} {0} {0} {0} {0} {0} {0} {0} {42} {0} {0} {4}}
		\end{bytefield}
	\end{center}
\end{frame}

\begin{frame}{Structs (Aggregate Types)}
	\begin{itemize}
		\item item
	\end{itemize}
\end{frame}

\begin{frame}{Struct Metadata}
	\begin{itemize}
		\item item
	\end{itemize}
\end{frame}

\section{Results}

\backmatter[notitle]
\end{document}
